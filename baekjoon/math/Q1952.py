## 달팽이2 (브론즈 1) *
# 달팽이가 이동할 수 있는 방향 
#   (동, 북, 서, 남)
dx = [0, -1, 0, 1]  
dy = [1, 0, -1, 0]

m, n = map(int, input().split())  # m: 세로 길이, n: 가로 길이

# m x n 크기의 2차원 배열을 생성하고, 초기값을 -1로 설정
g = [[-1] * n for _ in range(m)]

x = y = 0  # 시작 위치 (좌측 상단)
g[x][y] = 0  # 시작 위치의 값을 0으로 설정
cnt = 0  # 몇 바퀴를 돌았는지 카운트하는 변수
d = 0  # 현재 이동 방향 (우측)

while True:
    changed = False  # 방향을 전환하는지 여부를 저장하는 변수
    go = False  # 이동 가능한지 여부를 저장하는 변수
    for i in range(d, d+4):  # 현재 방향부터 시계방향으로 탐색
        nx, ny = x + dx[i%4], y + dy[i%4]  # 이동할 위치 계산
        # 이동할 위치가 배열 범위를 벗어나거나 이미 방문한 적이 있으면 스킵
        if nx < 0 or ny < 0 or nx >= m or ny >= n or g[nx][ny] != -1:
            changed = True
            continue
        go = True
        g[nx][ny] = 0  # 이동할 위치를 방문했다고 표시
        x, y, d = nx, ny, i%4  # 위치와 방향을 업데이트
        break
    # 현재 방향에서 이동 가능한 위치가 없다면 반복문을 종료
    if changed == True and go == True:
        cnt += 1  # 방향을 전환했으므로 바퀴 수를 증가
    if go == False:
        break
    
print(cnt)  # 바퀴 수 출력

'''
dx와 dy는 달팽이가 이동할 수 있는 방향을 나타내는 리스트입니다. 
각각의 원소는 우측, 하단, 좌측, 상단 방향을 나타내며, 
이동할 때 현재 위치에서 dx와 dy 리스트의 같은 인덱스에 
있는 값만큼 이동하면 됩니다.

예를 들어, 우측으로 이동할 때는 x좌표는 그대로 두고 
y좌표를 1 증가시켜야 하므로 dx[0]과 dy[0]에 저장된 
값 (0, 1)을 사용합니다. 
하단으로 이동할 때는 x좌표를 1 증가시켜야 하므로 dx[1]과 
dy[1]에 저장된 값 (1, 0)을 사용하고, 이와 같은 방식으로 좌측, 
상단 방향으로 이동할 때는 dx[2], dy[2]와 dx[3], dy[3]에 
저장된 값을 사용합니다.

따라서 dx와 dy 리스트를 이렇게 설정하는 이유는 달팽이가 
이동할 수 있는 방향을 나타내는 값들을 간단하게 저장하기 위해서입니다.
'''


'''

이 코드에서 x, y, d = nx, ny, i%4 다음에 break 하는 이유는, 
이동 가능한 위치를 찾았을 때, 해당 위치로 이동하고 반복문을 
빠져나와서 다음 단계로 진행하기 위함입니다.

즉, 이중 반복문에서 현재 위치에서 시계 방향으로 이동 가능한 
위치를 탐색할 때, 이동 가능한 위치를 찾으면 해당 위치로 이동하고 
반복문을 빠져나와서 다음 단계로 진행합니다. 

이때, break 문은 내부 반복문을 빠져나오는 역할을 합니다.
그리고 이동할 위치가 배열 범위를 벗어나거나 이미 방문한 
적이 있으면 스킵하고, 현재 방향에서 이동 가능한 위치가 없으면, 
반복문을 종료합니다. 

이때, 외부 반복문을 빠져나가는 break 문은 사용되지 않습니다. 
외부 반복문은 방향을 전환하여 다음 단계를 진행하기 때문에, 
이동 가능한 위치를 찾을 때까지 반복문을 계속 수행합니다.
'''
